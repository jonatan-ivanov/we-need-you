# We Need You

<!--
* resources for n00bs: Khan Academy, UDemy, and tons of others. CodeAcademy bootcamps. More. dont let anyone gate keep u from getting into the industry. it's usuaulyl BS and there's nothing particularly special about computer science. u can do it if u work at it. it's like anything else, just takes some practice. u really can become useful in a month. not an expert. but at leasr competent.
* we need more engineers in the community. maybe not in SF. but we do. 
* there's a need for qualified people in the US, too. look at mcrosoft having a headquarters in Canada. Its not about price. in america we educate people and send them away for want of work visas. lots of nice places to get good jobs. canada is one of them. if youre in the US, you might try working outside of SF. the supply for people is less outside of Sf and the pay is still pretty darned great.
* do u need a degree to get a job? no. its not required. but it helps. 
* the degree helps empliyeers know u have fundamentals and the ability to stick with a schedule and program for a period of time. 4 years. that's valuable, but is that the only thing you can do? nope. there are other things. 
  * github and oss contributions (ideal for contribution tags)
  * internships 
  * just do it. scratch ur own itch. 
* u need experience. u need to work at places that will give u opportinities to hone ur skills. if u come out of university then it will help assuage people's concerns that u may not know the basic, but its still just the first step. nothing beats experience. i know plenty of people with no degrees who are competent engineers and plenty of creddneitaled engineers i wouldnt want on my team. its jus thte bebinning. build a portfolio using github
* github shows u have coding chops. it also shows ur a team player. 
* software is a team sport. if ur laboring under the ideas that there are 10x developers, youve been badly misled. its a toxic idea people tell you to pressure u into working. dont be fooled. most software worth using was done by groups of people collaborating. the idea of the unicorn developer who retires into his (and this univorn is always a man, for some inscrutable reason!) cubicle and comes back a weekend later with a solution to keep the company solvent is toxic and infantile. most orgs would prefer a good developer who can work as a part of a team over a rockstar 10x dev. 10x developers are what we call people whove been isolzted and pressured into doing more than they need to or hsould. its a recipe for disasters. anybdoy can do impressive owrk if u dont overowrk them. u might risk burnt out otherwise.
* when u get into the industry, change jobs a lot. this is how id do it. 
* u want to be at a place wher ethey let u grow and where u can wear as many hat as u want (but no more), while also being large enough to be a reliable paycheck for a year. ins ilicon valley terms, lots of people leave their jobs after a year or two. u should strive to work as many jobs as u can in the beginnning. a number of reawsons. 
  * you can walk across the street and get a raise, faster theen the orgs can keep up with market rates (if theyre even inclined to do it)
  * u get a diverse edcation 
* the trick is to stay long enough to learn something but not so little that u dint profit. remember, employers will look at a resume with a bunch of 6 month stints and wonder what went wrong. but when u graduate univeristy these companies are going to try to take advantage of u. to get u on the job. to promise on the job education or in house universities with the concession u wont be paid well
* dont work for a company where its just u and some suit with an idea for an app that'll go big if u r just wlling to do all the work.
* ull prolly take a job being paid less than u deserve. thats true for everyone. its even worse, however, for POCs/minorities. so u have a strong incentive to keep moving until ur salary is in line with ur needs / expectations. 
* compensation is important. make sure theyre paying a fair wage. call them out if u suspect ur being underpaid. u want to work for an org that has happy engineers who feel equitably compensated. 
* also it helps to bank stocks.
* go to small companies at which you can grow into more releant. its no fun being a small unknown cog in a large machine. smaller orgs afford u more opportunities for growth. and growht is the name of the game, especially, in the beginning. its always important, but esp. as u start ur career. ur going to be at a disadvangage when u come out of univeristy. no matter how good it is, very few teach the practical day to day skills. ur gonna learn a ton on th ejob. internships are a good thing here too, but make usre ur nt taken advantage of.
* also much of sogrware is just workflow. learning how to work with people. there are, so far as i know, no Slack 101 classes in univeristy, but u will probably end up spending a lot of time in it or similar software just chatting with folks. the online watercooler. today its Slack. It was Lotus Notes 25 years ago. For a lot of people its still IRC and email.
* u can get some of that experience working in oss. oss is not quite a replacement for a degree nad the skill earned there but it does help assuage employers' concerns that u can code. and that u can collaborate. 
* lots of github projects have ideal for contribution issues. issues are items in te backlog for varous projects. feel free to pick some of those off and signal ur interest in them. this s a great chance to work with people who presuamnly know the code base and can teach u something. be humnle here. nobody knows everything. be willing to learn something if soneine is offering it. doing a small, sometimes trivial chores, is a great way to ingratiate urself with the maintainers of the project. its also a great way to open up a dialog, to begin the discussion and the journye to becoming a prolific contributor or even a committer. try it out now. go find one issue on one project u want to work on. there are literally MILLIONS of them on gthub so you shouldnt want for opportunities. 
* when u find a job , u will need to think about  compensation. it simportant. u want to be paid well but u also need to realie that money is only part of the problem. it wont take long befroe ur at a job that covers all ur requirements. it pays the rent (or mortgage, if ur in the US and ur any kind of smart), food and leaves u with a little in the bank for savings. if u get to that place, then u need to realize that ur job is to optimize for happiness. 
* rememberL money isnt everything. satisfy ur monthly nut and then u will be happy. more money doesnt make u happier. after all, if u have neought to provide for ur family, accomodate shelter and food and savings, then ur ok. 
* if ur working and doing ur best job, then being offrered more money can be insulting. 
* what motivates people? 
* drive daniel h pinks book has 3 "drives." the first is basics survival. the secon dis carrot and stick. the third is self. we do things we feel invested in
* do lot sof jobs, but realize that u need to be happy. lets say u stay at an employer, bank some stocks, and sacvings, and then move on. but u liked the last place. dont despair. u can always go home again. dont burn bridges. this is very important in this industry. it's super small.  lreave on good grounds. its impossible to avoid others in this industry. 
* when u get into the world dont let people burn u out. if u love what u do, u will never work a day in ur life. 
* learn to cut urself off and relax. do rubber ducking. play tetris. take an archimedian bath. do things to encourae the flow of juices. "passion" in a programmer job reqs is code for "we want to work u to the bones." 
* pivotal does pair programming; we encourage people to spend just their normal day and then go home. most people dont have the abulity to do more than 8h a day. its burntout territoty. some clients even pay programmeres in other lines of work extra money to NOT work mor ethan 8h a day becuase they dont want to get billed for subpar work.
* most people dont get a full 8 h of focus a day .
* focus is har dto achevie. if ur really lucky u can get into the zone. people love gttingin the zone. programmers, video games, coke addicts, etc, all feel that sense of satisfcation of geting into the zone. people love it. get into the zone. do the thing that lets you feel like ur making perceiptble progress towards a goal. its the fast feedback loops that make it so exhillerating to be in softare. beyond money, people crave usccesses and they crave the abilit to feel invested in something. if somebody feels like theyre doing work that benefits them as well as the org, they become excited to do it. antoine de expury bark orders make them yearn for the vast and endless seas. 

-->

## Motivations

I put the lugage in the trunk and got into the Uber. I wasn't quick enough or conspicuous enough in putting on my headsets and the driver asked the usual question: 

"Where are ya going?" 

"Tokyo," I said. 

"Oh, fun! Business or pleasure?" 

"Both?" 

"How long will you be there?" 

"36 hours." 

"36 hours! What line of work are you in, if you don't mind my asking?" 

"Software." 

Then the predictable question arrives: what would I recommend the Uber driver do to break into software? Everybody wants some of that hustle. I understand. It wasn't too long that I was on the outside looking in, too! I want more people to join the industry. Goodness knows we need more people. Especially more people of colors and other minorities. We need more diversity. We need more qualified people. So I abandon the podcast I was about to listen and start talking to the Uber driver. It's a conversation I've had a hundred times this year in Ubers all over the world. 

There's clearly a dearth of insight (or whatever it is I will attempt to offer here) on this topic, so I've (finally!) decided to just try writing it all down for ease of referencability. I hope this helps somebody out there. If you have questions, I'm always happy to [lend a listening ear on Twitter (@starbuxman)](http://twitter.com/starbuxman).

Keep in mind that I've been a professional programmer since 2002. I'm going to do my best to be helpful with these answers, and I'll draw where applicable from lived experiences, but a lot has changed since I got into the business. I'll try to note what I've observed. 

## Getting Started with Programming 

This question is one I get all the time. It's hard to give a good, solid, one-size-fits-all answer. First of all, there's no single kind of programming. That is to say, it's a bit like medicine: you're going to specialize in something. Nobody does _everything_ for every job. And that's OK. You're going to find your nice and trade niches every now and then as you career progresses. 

So your first job is to learn to write a basic computer program. Programs often share a lot of similar concepts: variables, functions, objects, if/else, loops and other control-flow mechanisms, etc. Once you've got the hang of doing one of all these things in one language, and can kind of intuit where you might use each one, then you can take those semantics and apply them to other languages. Other languages might prioritize their unique way of doing any one of those things as being more important in the use of the language, but ultimately, you're going to deal with some or all of those concepts. The syntax may change frequently while the semantics change more infrequently.

When I was a child, my dad took me to Barnes & Nobles. They were (are?) a bookseller. There was an adjoining Starbucks. We were relatively poor, so we'd go into the Starbucks. I'd buy a "venti-drip" - a large, 20oz. cup of black coffee - and then wander into the connected Barnes & Nobles bookstore. I'd invariably have a backpack with a clipboard. I'd use the clipboard (and paper! and pencils! and other assorted things I wouldn't know where to find in my own home these days) and the notepad on it and I'd read bookd on computer programming. I'd scrawl notes and programs on the notepad. 

We couldn't afford those often $50+ books. So I'd sit on the hard floor surroinded by a stack of books. Just chipping away, noting enough stuff down to tide me over until I could get back next weekend. Years later when I started earning enough money to afford books, one of the first things I wanted to do was to buy books. I loved them. I stockpiled them. Had to buy increasingly bigger IKEA bookshelves to accomodate them. 

Later in life, when I got my first publishing deal for a book, I insisted that the publisher also give me unlimited access to their books as .PDFs. I wanted to legally own books! 

Today, in December 2019, the situation is _very_ different. There's always been access to credible articles and blogs and Usenet posts on computer programming, but I feel - perhaps a bit biased - that today's programmer has access to infinitely more (free!) resources to get started. These are not scattershot little articles, these are entire courses you can take that take you from novice to a working program. There are too many to count. I'll list a few resources that I got back when I googled "intro to programming" and the name of a site.

* [Khan Academy](https://www.khanacademy.org/computing/computer-programming)
* [Udemy](https://www.udemy.com/course/introduction-to-programming-level-i/)
* [Coursera](https://www.coursera.org/courses?query=intro%20to%20programming)
* [Code Academy](https://www.codecademy.com/catalog/subject/all)

I didn't list YouTube, but there are, of course, a _ton_ of good options out there. If I were you, I'd look for tutorials on a language like [Python](https://www.python.org/) which offers a nice, easy introduction to computer programming concepts. 

There are also so-called bootcamps. These are live, in-person programs that teach you how to code. Usually they're heavy on applied computer science and light on the academics and concepts. The goal is to get you a job. These bootcamps aren't free, but they often work. They teach you enough to be useful. If you're any kind of curious, you'll be armed with your familiarity of whatever you've leared at that bootcamp to then soak up other, adjacent concepts. Do that enough and you have yourself a ballgame. 

The bootcamps are _definitely_ not free - some can even be quite expensive! But [many of them will defer your tuition fees](https://studentloanhero.com/featured/coding-boot-camps-deferred-tuition/) until after you've landed a job. Some will even go a step further and condition your tuition fees on the very fact of you securing a job! I've never used any of these, but suffice it to say that they exist and you might research them if you're so inclined. 

These bootcamps are a testament to the idea that being a programmer isn't something so hard that only the unicorn geniuses can do it. People who tell you it's too difficult are trying to act as gate keepers; ignore them. If I can do this work, then you definitely can too. I am also inherently suspicious of anybody who _doesn't_ want more people in technology. After all, we _need_ you in our communities. 

## We Need You More Than You Need Us 

We need you, more than you need us. Companies today are no longer struggling to find analog use caases that might become digital. They'e digital-first, at this point. Almost all businesses are software businesses. In order to be successful, you will need to deploy software. This creates a growing market for programmers. Whoever controls the computers controls the world. 

I believe that programming should be a fundamental skill, like cursive used to be, taught in every school. It's hard to imagine how something so foundational to our society - computer systems - ended up being controlled by the elite few. We need to fix this. To put back computers in the hands of the everyperson.

### The United States Needs You

In the United States, in particular, we've long had a talent shortage. There aren't [enough H1B visas](https://www.vox.com/2019/2/28/18241522/trump-h1b-tech-work-jobs-overseas) to allow technology workers to come in. We've got demand, but not enough people, so technology companys try to bring in folks from overseas. They do this with VISAs that allow people to enter the country to do work. Keep in mind, this _isn't_ outsourcing! They're bringing the people to the work in the United States, _not_ sending the work to people overseas. This _isn't_ cheaper. It's markedly more expensive for American companies to sponsor people and support their relocation. If American companies could hire locally, and get the qualified people they need, they would. 

Another common strategy is setting up another office in other countries with more indulgent VISA allotments. Some companies setup offices in our neighbor Canada where - generally - the cost of living is as much or more than the equivalent costs in nearby US state Washington or Oregon and the employer also has to pay more in taxes for things like mandated, single payer healthcare. Again, this isn't a cheaper option than hiring locally. It's just what these companies need to do to meet the demand.

### No, Really, We Need You. Yes, _YOU_. 

Ignore the talent shortage, dear reader, and we still have one other, global, problem. The software industry right now is slowly going through a bit of internal soul-searching. In the last decade it's become crystal clear that the world of software is (awkwardly) dominated by men. And typically only a few varieties of men. In the US, there are very few people of color, or monorities, in software. There are very few women. 

Here are some diversity numbers from Apple and Google that I pulled from a CNBC article, [_Silicon Valley’s Achilles’ heel threatens to topple its supremacy in innovation_](https://www.cnbc.com/2018/06/20/silicon-valleys-diversity-problem-is-its-achilles-heel.html).

    > The numbers for all employees break down as follows: 21 percent of Apple employees are Asian, 9 percent are black, 13 percent are Hispanic, and 3 percent are multiracial. Some 54 percent are white. Women make up only 23 percent of workers in tech roles and 32 percent of employees overall, according to Apple.

    > Google found similar results in its diversity report: In 2017, Google’s overall workforce was 56 percent white, 35 percent Asian, 4 percent Hispanic, 2 percent black and less than 1 percent American Indian or Alaskan Native, and Native Hawaiian or Pacific Islander.

It's not hard to identify some of the nefarious reasons for this result. There are the more obvious reasons for this situation. Some people gatekeep. They want to ensure theirs a more prized position by forcing scarcity of supply. And it would be nice to be able to believe that things are getting better, but the fact remains that there are bigots out there. Overt racists and homophobes and whatever. And of course, there's toxic masculanity, which seems to rear its ugly head all the time.

And for every blatant and smill-minded bigot in the categories I've just described there are several more who - I imagine - don't wake up and laugh maniacally that they just can't wait to impede the careers of women, minorities and POCs. These people are not cartoon villain people utterly lacking in empathy. But they're human. And they have biases that get reinforced by their surroundings. These biases are there, and sometimes manifest unbenknownst to their bearers. 

One place where biases manifest "subconciously" is in hiring. I scare-quote that word because I don't want to let people off the hook for their biases, even if - once confronted and made aware of what the results were - they wanted to immediately undo it. It's still a problem. But I want to beleive these people want to get better. I certainly want to excise my unconcious biases.

Some organizations are doing things to combat bias. One such practice is to route resumés through an independant service that strips all incoming resumés of any indications of gender, culture, or anything else, leaving only the acheivements and qualifications of the person. Even well-intentioned employers end up making more diverse hires through this process. There are obvious benefits to this: an environment with a diversity of ideas and insights can produce more solutions than a more mypic one. It also makes interpersonal skills more important, and results in an organiation that prizes team players. But did you know that [companies with more racial and ethnic diversity are 30% more likely to have financial returns above peers](https://www.forbes.com/sites/ruchikatulshyan/2015/01/30/racially-diverse-companies-outperform-industry-norms-by-30/)?

Tentpole companies in Silicon Valley are aware of the issues in hiring and some have started to make strides in replenishing their ranks. It's slow work logistically, one imagines. Hopefully, companies hire with diversity and inclusion in mind going forward, but they still have their existing, possibly non-diverse workforce. They can't very well fire everyone and start over. The less divorce a workforce, the less inclined and welcomed diverse people will feel joining that workforce. This creates a vicious cycle, indeed. 

## Degree or not Degree: That Is the Question

"Alright already!" I imagine you exclaim. Maybe you didn't need to be persuaded to take that next step. Maybe you're here because you want to figure out _how_ to do it. What's the easiest path in? And, here, I don't know what to tell you. I think about my little girl a lot here. What would I tell her? I would tell her she needs a degree. Are there other ways into the business short of a degree? Sure. Tons! It's not, strictly speaking, required that you obtain a degree to work in this industry. Tons of the best developers I know don't have degrees in computer science, or - if they do have degrees, they're often entirely unrelated to computer science. I have a lot of friends who have higher degrees in physics or music, for example. Something about those two pursuits that drives people to software for reasons I suppose I'll never understand. 

You have to consider what an employer is trying to do: they're trying to minimize risk. They don't want to invest in an unknown quanity. Nobody does. And, certainly, they won't want to invest at the prices organizations pay in Silicon Valley! 

Anybody in this industry will tell you that there are seemingly as many imminently qualified engineers with no degree as there are terrible engineers with a degree. A degree does _not_ entirel de-risk the hiring of someone. But it's a good bet. A degree, any degree, tells hiring organizations that you can stick to a schedule (and manage time), that you have the discipline and drive to cross the finish line, that you are williing to do hard work, and that you can follow through. After a certain point in your life, those skills mean far more than whatever you learned in any particular course, whose utility will likely erode in time anyway. 

One thing many schools don't teach you is how to be a team-player. We'll revisit this point. 

A degree solves the chicken-and-egg problem: you need experience to give an organization confidence that you can do a good job; but you can't get hired and get that experience without prior experience. Good organizations know that an engineer never stops learning; there's no such thing as a fully-formed engineer. It's important to be well-rounded, and to have a sense of what you'd reach for in a given situation, but depth comes with application and hard work. You'll always have to learn something, someday. A good organization will encourage the learning process, not penalize it. So when, as a young engineer, you join an organization, you'll be expected to learn on the job. They _know_ you don't have every skill you'll need to do the job. Nobody does! And, a corollary to that, by the way, is that if you _truly_ do have every skill you need to do your first job, it's probably not a job you want to spend a long time at. Strive to find places where you can grow! 

Beyond the basics of programming and computer-science in general, your ability to do a particular thing is _not_ what is represened by a degree. Don't get me wrong; if you have a focus in something like machine learning, distributed systems or whatever else, you'll benefit from being able to show that you've had a few years studying the topic. But these fields are so vast that a couple of years doesn't buy you much in the way of credibility. There are other means of obtaining that credibility. 

Remember: there's a tension that institutions of higher learning have to negotiate: ground the learner in fundamentals and theory, and hopefully give them the skills needed to participate in the industry, with the understanding that there's still a lot of learning to be done before they're useful in industry, or lean towards pragmatism with more vocational training. It's hard to do both completely and there's no right answer here. It's more about what the local market demands. I tend to think that more time learning fundamentals is critical, but I really hope people graduate with a sense that - in the real world  - they will be spending time with others, and that a ton of what people spend their time doing in industry is learning how to collaborate with things like Github, Slack, e-Mail, and indeed whole software methodologies like agile programming. Some of these things are ephemeral; who knows how long Slack will be around? But their use is typical of any generation of software development. 

How else can you assuage an organization's concerns about hiring you? How else can you persuade them that you've got what it takes? Remember, they're looking for people that they'd feel happy to welcome to the team. People who pull their weight. There are other - and some might argue better - ways of demonstrating these  qualities. 

One of my favorites today is Github. Github is a social network for developers. If you haven't used it before then you _absolutely_ should. Learn how the Git version control system works, and then learn how Github works. Git is a technology for managing source code. It makes it easy for teams of people to collaborate on the same codebase, hopefully avoding conflicting changes to the codebase. Software is a team sport. Tools that better suppport collaboration represent major leaps forward in industry. A typical software project is composed of source code files. There may be one or (more likely) many source code files. All of these source code files need to be stashed somewhere so that everyone involved in the development cycle can pull down the files to their local machine, make changes, and eventually synchronize them back to the original source code, ideally without stepping on each other's toes. Git solves this (admittedly) mundane problem. Github is a service - a website at www.Github.com - that makes it trivial to create new (and free) Git repositories and then invite people to collaborate with you. So, if you only had Git, you'd have to install your own Git server, and ensure that you had security setup for all involved users. You'd have to setup a computer and backup hard disks and all that. With Github, all that process goes away. You can go from idea to a new repository admitted team members in a minute. It's that fast! 

Github also makes it super easy to search and surface interesting repositories. There are millions (tens of millions? billions?) of software projects hosted on Github.com. A good deal many of them are open-source - you can see the source code. Even better, the open-source model encourages collaboration. If you can see the source code then you can use the source code. If you like the source-code - if it scratches a particular itch of yours - then you can use it as-is _or_ improve it as you see fit or needed. We call this "scratching our own itch." Even better, you can submit the changes you've made to the code back tot he original repository. Now, everyone else benefits from the work you've put into it. This iterative approach - where random people can consume and expand upon other people's code for the betterment of the entire communit - has _really_ powerful implications. 

Suppose you found a Github repository that does most of what you are dreaming of in a solution to a problem you've got. Suppose you wanted to build a bot for Facebook messenger. There's a lot of work involved in doing that. If you could build upon somebody else's work, customizing it as required to support your usecase, then you could effectively a lot of the initial development. All you need to do is worry about taking that source code the last-mile. You "scratch your itch," molding the code as required to support your usecase, and now you've decided you want to contribute this change back. You can engage the team working on the project. Talk to them. Learn from them. They originated the code, so they'll know the project better than you might. Perhaps they could mentor you. Perhaps they could help you flesh out a solution that would be worthy of inclusion in the codebase, if you were to go off and implement that solution. You can send back your changes as a "pull-request," which the team can choose to accept into the codebase or to ignore. Now, the next person who comes along benefits from both the original work and your work. Even better, your contributions to the project are documented. Your efforts have a digital papertrail. This papertrail demonstrates a lot of what I or most organizations would want out of a new hire. Can that person work well with others? Learn the codebase and the technology on the flow? Start and then deliver something? Share? And all the while maintain a quality contribution? 

Github is a great way to learn more. It's a great way to level up your skills. It's also a great way to score some quality mentorship with people whose skills you admire, appreciate, or respect. Having your contributions accepted into a big project with gifted engineers is a very rewarding experience. That's _one_ way to help persuade an organization of your worth. Indeed, if you make enough contributions, the organizations will often find you before you find them. 

Keep in mind that your every line of code in industry will not, statistically speaking, be in open-source Github projects. You may not even use Github for your source code host. Plenty of people prefer on-premise tools like Gitlab to confer a Github-like experience, but hosted privately within an organization. 

Another great way to help de-risk your hire, very much in the same vein as Github, is to get accepted as an intern. The easiest way to do this is through a university which facilitates them, but it's not the only way. Some organizations invite people to apply. Software companies in Silicon Valley don't pay a ton for internships, but they're useful in small doses, to give you daily, applied, software development experience. It's not a pretty job, but _somebody_ has to do it! You learn a lot about the process, around the edges, when doing actual work with a team. 

There's another channel, but I don't know if I could recommend it. You might pursue certification. I remember getting the Sun Certified Java Programmer certification back in 2002. I don't know if that certification opened any doors for me or not. I don't think it did. I don't think any company even asked about it. Today is a different world and your mileage may vary. I suspect I would care about a certification for things like cloud computing infrastructure in today's world since those are whole other worlds of complexity separate and apart from the world of programming with which programmers will need familiarity. It'd be nice to know that a potential hire could jump right into the deep end of production deployments.

Or, maybe some mix of these approaches is right for you. Work on Github when you have some free time, but also attend university. Or also do a bootcamp. Find ways to demonstrate experience. 

## Software is a Team Sport

I want to re-iterate this. It's super important. **Software is a team sport**. Most software you use in your day to day experience was developed with other people. It is the product of collaboration. I know that it's easy to draw the conclusion that developers are the socially awkward, typically male, lone-hero types who surround themselves with terminals scrolling at nonsensical speeds in dark rooms, but this is all utter nonsense. Most software is written in the light of day with other people who are often just staring at a single screen trying to figure things out. Softea 

I've been in industry since 2002, working professionally on software. It was many years even before then that I last felt confused about the tokens that I was required to type. Or the syntax I was required to use. Appeasing the compiler is almost never my problem these days. Indeed, the compiler starts to become your friend after a while; it takes away some of the uncertainty of programming and lets you focus on the rest of the process. And that is a good thing, because there is a lot to focus on. 

Hat tip to [Josh McKenty](http://twitter.com/jmckenty) on finding [this epic document](http://tantek.pbworks.com/w/page/19402879/CommunicationProtocols) on all the ways people in organizations communicate and _why_ they communicate.

## Never Stop Learning

## Don't Be Afraid To Move On, Especially in the Beginning 

## After a Point, Your Compensation... Does Not Compensate. 

## Drive 3.0

## Burnout 

## Rewarding Work is More Than Just Lucrative Work 

## Getting into "The Zone"

## To Infinity and Beyond! 
